{
    "docs": [
        {
            "location": "/",
            "text": "zend-httphandlerrunner\n\n\n\n\n\n\nThis library provides utilities for:\n\n\n\n\nEmitting \nPSR-7\n responses.\n\n\nRunning \nPSR-15\n server request handlers,\n  which involves marshaling a PSR-7 \nServerRequestInterface\n, handling\n  exceptions due to request creation, and emitting the response returned by the\n  composed request handler.\n\n\n\n\nThe \nRequestHandlerRunner\n will be used in the bootstrap of your application to\nfire off the \nRequestHandlerInterface\n representing your application.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-httphandlerrunner\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "zend-httphandlerrunner"
        },
        {
            "location": "/#zend-httphandlerrunner",
            "text": "This library provides utilities for:   Emitting  PSR-7  responses.  Running  PSR-15  server request handlers,\n  which involves marshaling a PSR-7  ServerRequestInterface , handling\n  exceptions due to request creation, and emitting the response returned by the\n  composed request handler.   The  RequestHandlerRunner  will be used in the bootstrap of your application to\nfire off the  RequestHandlerInterface  representing your application.",
            "title": "zend-httphandlerrunner"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-httphandlerrunner",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "zend-httphandlerrunner\n\n\nThis component provides  utilities for:\n\n\n\n\nEmitting \nPSR-7\n responses.\n\n\nRunning \nPSR-15\n server request handlers,\n  which involves marshaling a PSR-7 \nServerRequestInterface\n, handling\n  exceptions due to request creation, and emitting the response returned by the\n  composed request handler.\n\n\n\n\nThe \nRequestHandlerRunner\n will be used in the bootstrap of your application to\nfire off the \nRequestHandlerInterface\n representing your application.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#zend-httphandlerrunner",
            "text": "This component provides  utilities for:   Emitting  PSR-7  responses.  Running  PSR-15  server request handlers,\n  which involves marshaling a PSR-7  ServerRequestInterface , handling\n  exceptions due to request creation, and emitting the response returned by the\n  composed request handler.   The  RequestHandlerRunner  will be used in the bootstrap of your application to\nfire off the  RequestHandlerInterface  representing your application.",
            "title": "zend-httphandlerrunner"
        },
        {
            "location": "/usage/",
            "text": "Installation and Usage\n\n\nTo install this package, run the following \ncomposer\n\ncommand:\n\n\n$ composer require zendframework/zend-httphandlerrunner\n\n\n\nThe package provides both \nemitters\n and the \nrequest handler\nrunner\n, and these are generally used within the bootstrap of your\napplication.\n\n\nWe recommend using a dependency injection container to define your various\ninstances, including the \nPSR-15\n request\nhandler representing your application, the response emitter, the server request\nfactory, the server request error response generator, potentially, the runner\nitself.\n\n\nThe example below instantiates the runner manually by pulling its dependencies\nfrom a configured \nPSR-11\n container.\n\n\nuse Zend\\HttpHandlerRunner\\Emitter\\EmitterStack;\nuse Zend\\HttpHandlerRunner\\RequestHandlerRunner;\n\n$container = require 'config/container.php';\n\n$runner = new RequestHandlerRunner(\n    $container->get(ApplicationRequestHandler::class),\n    $container->get(EmitterStack::class),\n    $container->get('ServerRequestFactory'),\n    $container->get('ServerRequestErrorResponseGenerator')\n);\n$runner->run();",
            "title": "Usage"
        },
        {
            "location": "/usage/#installation-and-usage",
            "text": "To install this package, run the following  composer \ncommand:  $ composer require zendframework/zend-httphandlerrunner  The package provides both  emitters  and the  request handler\nrunner , and these are generally used within the bootstrap of your\napplication.  We recommend using a dependency injection container to define your various\ninstances, including the  PSR-15  request\nhandler representing your application, the response emitter, the server request\nfactory, the server request error response generator, potentially, the runner\nitself.  The example below instantiates the runner manually by pulling its dependencies\nfrom a configured  PSR-11  container.  use Zend\\HttpHandlerRunner\\Emitter\\EmitterStack;\nuse Zend\\HttpHandlerRunner\\RequestHandlerRunner;\n\n$container = require 'config/container.php';\n\n$runner = new RequestHandlerRunner(\n    $container->get(ApplicationRequestHandler::class),\n    $container->get(EmitterStack::class),\n    $container->get('ServerRequestFactory'),\n    $container->get('ServerRequestErrorResponseGenerator')\n);\n$runner->run();",
            "title": "Installation and Usage"
        },
        {
            "location": "/runner/",
            "text": "The Request Handler Runner\n\n\nZend\\HttpHandlerRunner\\RequestHandlerRunner\n can be used to \nrun\n a\n\nPSR-15\n \nRequestHandlerInterface\n instance.\nBy this, we mean:\n\n\n\n\nMarshal a server request instance.\n\n\nHandle exceptions due to marshaling the server request instance.\n\n\nPass the request to the composed request handler.\n\n\nPass the response generated by the request handler to the composed \nemitter\n\n\n\n\nThe runner takes four constructor arguments, in the following order:\n\n\n\n\nA \nPsr\\Http\\Server\\RequestHandlerInterface\n instance.\n\n\nA \nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n instance.\n\n\nA PHP callable to generate a \nPsr\\Http\\Message\\ServerRequestInterface\n instance.\n\n\nA PHP callable that can generate a \nPsr\\Http\\Message\\ResponseInterface\n\n  instance given a PHP \nThrowable\n generated by the server request factory\n  from the third argument.\n\n\n\n\nOnce constructed, you may call the method \nrun()\n:\n\n\n$runner->run();\n\n\n\nServer request factory\n\n\nThe \n$serverRequestFactory\n argument to the constructor may be any PHP callable\nthat accepts no arguments (or all optional arguments), and which returns a\n\nPSR-7\n \nServerRequestInterface\n instance.\n\n\nAs an example, using \nzend-diactoros\n:\n\n\nuse Zend\\Diactoros\\ServerRequestFactory;\n\n$serverRequestFactory = [ServerRequestFactory::class, 'fromGlobals'];\n\n\n\nAlternately, a \nPSR-17 (proposed specification for HTTP message\nfactories)\n factory may be used:\n\n\nuse HttpInterop\\Implementation\\ServerRequestFactory;\n\n$serverRequestFactory = function () use ($_SERVER, $factory) {\n    return $factory->createServerRequestFromArray($_SERVER);\n};\n\n\n\nServer request error response generator\n\n\nIn rare cases, the server request factory may raise a PHP \nThrowable\n or\n\nException\n. In those cases, the runner still needs to generate a response to\nemit.\n\n\nThe server request error response generator argument to the\n\nRequestHandlerRunner\n constructor may be any PHP callable that accepts a PHP\n\nThrowable\n argument, and which returns a PSR-7 \nResponseInterface\n instance.\n\n\nAs an example, \nzend-stratigility\n\nprovides the class \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n, which\nis typically used with its \nErrorHandler\n to generate a response. It can be\nre-purposed if we curry in empty server request and response instances as\nfollows:\n\n\nuse Throwable;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\ServerRequest;\nuse Zend\\Stratigility\\Middleware\\ErrorResponseGenerator;\n\n$errorResponseGenerator = function (Throwable $e) {\n    $generator = new ErrorResponseGenerator();\n    return $generator($e, new ServerRequest(), new Response());\n};\n\n\n\nRequest handlers\n\n\nRequest handlers MUST implement \nPsr\\Http\\Server\\RequestHandlerInterface\n.\nAdditionally, for best results, they MUST provide their own error and exception\nhandling, to ensure that a response is returned and the runner is able to emit a\nresponse.",
            "title": "Request Handler Runner"
        },
        {
            "location": "/runner/#the-request-handler-runner",
            "text": "Zend\\HttpHandlerRunner\\RequestHandlerRunner  can be used to  run  a PSR-15   RequestHandlerInterface  instance.\nBy this, we mean:   Marshal a server request instance.  Handle exceptions due to marshaling the server request instance.  Pass the request to the composed request handler.  Pass the response generated by the request handler to the composed  emitter   The runner takes four constructor arguments, in the following order:   A  Psr\\Http\\Server\\RequestHandlerInterface  instance.  A  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface  instance.  A PHP callable to generate a  Psr\\Http\\Message\\ServerRequestInterface  instance.  A PHP callable that can generate a  Psr\\Http\\Message\\ResponseInterface \n  instance given a PHP  Throwable  generated by the server request factory\n  from the third argument.   Once constructed, you may call the method  run() :  $runner->run();",
            "title": "The Request Handler Runner"
        },
        {
            "location": "/runner/#server-request-factory",
            "text": "The  $serverRequestFactory  argument to the constructor may be any PHP callable\nthat accepts no arguments (or all optional arguments), and which returns a PSR-7   ServerRequestInterface  instance.  As an example, using  zend-diactoros :  use Zend\\Diactoros\\ServerRequestFactory;\n\n$serverRequestFactory = [ServerRequestFactory::class, 'fromGlobals'];  Alternately, a  PSR-17 (proposed specification for HTTP message\nfactories)  factory may be used:  use HttpInterop\\Implementation\\ServerRequestFactory;\n\n$serverRequestFactory = function () use ($_SERVER, $factory) {\n    return $factory->createServerRequestFromArray($_SERVER);\n};",
            "title": "Server request factory"
        },
        {
            "location": "/runner/#server-request-error-response-generator",
            "text": "In rare cases, the server request factory may raise a PHP  Throwable  or Exception . In those cases, the runner still needs to generate a response to\nemit.  The server request error response generator argument to the RequestHandlerRunner  constructor may be any PHP callable that accepts a PHP Throwable  argument, and which returns a PSR-7  ResponseInterface  instance.  As an example,  zend-stratigility \nprovides the class  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator , which\nis typically used with its  ErrorHandler  to generate a response. It can be\nre-purposed if we curry in empty server request and response instances as\nfollows:  use Throwable;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\ServerRequest;\nuse Zend\\Stratigility\\Middleware\\ErrorResponseGenerator;\n\n$errorResponseGenerator = function (Throwable $e) {\n    $generator = new ErrorResponseGenerator();\n    return $generator($e, new ServerRequest(), new Response());\n};",
            "title": "Server request error response generator"
        },
        {
            "location": "/runner/#request-handlers",
            "text": "Request handlers MUST implement  Psr\\Http\\Server\\RequestHandlerInterface .\nAdditionally, for best results, they MUST provide their own error and exception\nhandling, to ensure that a response is returned and the runner is able to emit a\nresponse.",
            "title": "Request handlers"
        },
        {
            "location": "/emitters/",
            "text": "Emitters\n\n\nEmitters are used to \nemit\n a \nPSR-7\n\nresponse. This should generally happen when running under a traditional PHP\nserver API that uses output buffers, such as Apache or php-fpm.\n\n\nEmitters are described by \nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface EmitterInterface\n{\n    public function emit(ResponseInterface $response) : bool;\n}\n\n\n\nTypically, such emitters will perform the following:\n\n\n\n\nEmit a response status line.\n\n\nEmit all response headers.\n\n\nEmit the response body.\n\n\n\n\n(The first two items may be swapped in order; many SAPIs allow emitting multiple\nstatus lines, and will use the last one present. As such, most implementations\nwill emit the status line after the headers to ensure the correct one is emitted\nby the SAPI.)\n\n\nThe \nemit()\n method allows returning a boolean. This value can be checked to\ndetermine if the emitter was able to emit the response. This capability is used\nby the provided \nEmitterStack\n to allow composing multiple emitters that can\nintrospect the response to determine whether or not they are capable of emitting\nit.\n\n\nSapiEmitter\n\n\nZend\\HttpHandlerRunner\\Emitter\\SapiEmitter\n accepts the response instance, and\nuses the built-in PHP function \nheader()\n to emit both the headers as well as\nthe status line. It then uses \necho\n to emit the response body.\n\n\nInternally, it also does a number of verifications:\n\n\n\n\nIf headers have been previously sent, it will raise an exception.\n\n\nIf output has been previously sent, it will raise an exception.\n\n\n\n\nThese are performed in order to ensure the integrity of the response emitted.\n\n\nIt also filters header names to normalize them; this is done in part to ensure\nthat if multiple headers of the same name are emitted, the SAPI will report them\ncorrectly.\n\n\nThis emitter can \nalways\n handle a response, and thus \nalways\n returns true.\n\n\nSapiStreamEmitter\n\n\nZend\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter\n behaves similarly to the\n\nSapiEmitter\n, with two key differences:\n\n\n\n\nIt allows emitting a a \ncontent range\n, if a \nContent-Range\n header is\n  specified in the response.\n\n\nIt will iteratively emit a range of bytes from the response, based on the\n  buffer length provided to the emitter during construction. This is\n  particularly useful when returning \nfiles\n or \ndownloads\n.\n\n\n\n\nThe emitter accepts an integer argument to the constructor, indicating the\nmaximum buffer length; by default, this is 8192 bytes.\n\n\nThis emitter can \nalways\n handle a response, and thus \nalways\n returns true.\n\n\nEmitterStack\n\n\nZend\\HttpHandlerRunner\\Emitter\\EmitterStack\n allows providing a\nlast-in-first-out (LIFO) stack of emitters instead of a single emitter. If an\nemitter is incapable of handling the response and returns \nfalse\n, the stack\nwill move to the next emitter. If an emitter returns \ntrue\n, the stack\nshort-circuits and immediately returns.\n\n\nThe \nEmitterStack\n extends \nSplStack\n, and thus allows you to add emitters using\nany of the methods that class defines; we recommend adding them in LIFO order\nusing \npush()\n:\n\n\n$stack->push($last);\n$stack->push($second);\n$stack->push($first);\n\n\n\nConditionally using the SapiStreamEmitter\n\n\nThe \nSapiStreamEmitter\n is capable of emitting any response. However, for\nin-memory responses, you may want to use the more efficient \nSapiEmitter\n. How\ncan you do this?\n\n\nOne way is to check for response artifacts that indicate a file download, such\nas the \nContent-Disposition\n or \nContent-Range\n headers; if those headers are\nnot present, you could return \nfalse\n from the emitter, and otherwise continue.\nYou could achieve this by decorating the \nSapiStreamEmitter\n:\n\n\n$sapiStreamEmitter = new SapiStreamEmitter($maxBufferLength);\n$conditionalEmitter = new class ($sapiStreamEmitter) implements EmitterInterface {\n    private $emitter;\n\n    public function __construct(EmitterInterface $emitter)\n    {\n        $this->emitter = $emitter;\n    }\n\n    public function emit(ResponseInterface) : bool\n    {\n        if (! $response->hasHeader('Content-Disposition')\n            && ! $response->hasHeader('Content-Range')\n        ) {\n            return false;\n        }\n        return $this->emitter->emit($response);\n    }\n};\n\n$stack = new EmitterStack();\n$stack->push(new SapiEmitter());\n$stack->push($conditionalEmitter);\n\n\n\nIn this way, you can have the best of both worlds, using the memory-efficient\n\nSapiStreamEmitter\n for large file downloads or streaming buffers, and the\ngeneral-purpose \nSapiEmitter\n for everything else.",
            "title": "Emitters"
        },
        {
            "location": "/emitters/#emitters",
            "text": "Emitters are used to  emit  a  PSR-7 \nresponse. This should generally happen when running under a traditional PHP\nserver API that uses output buffers, such as Apache or php-fpm.  Emitters are described by  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface :  use Psr\\Http\\Message\\ResponseInterface;\n\ninterface EmitterInterface\n{\n    public function emit(ResponseInterface $response) : bool;\n}  Typically, such emitters will perform the following:   Emit a response status line.  Emit all response headers.  Emit the response body.   (The first two items may be swapped in order; many SAPIs allow emitting multiple\nstatus lines, and will use the last one present. As such, most implementations\nwill emit the status line after the headers to ensure the correct one is emitted\nby the SAPI.)  The  emit()  method allows returning a boolean. This value can be checked to\ndetermine if the emitter was able to emit the response. This capability is used\nby the provided  EmitterStack  to allow composing multiple emitters that can\nintrospect the response to determine whether or not they are capable of emitting\nit.",
            "title": "Emitters"
        },
        {
            "location": "/emitters/#sapiemitter",
            "text": "Zend\\HttpHandlerRunner\\Emitter\\SapiEmitter  accepts the response instance, and\nuses the built-in PHP function  header()  to emit both the headers as well as\nthe status line. It then uses  echo  to emit the response body.  Internally, it also does a number of verifications:   If headers have been previously sent, it will raise an exception.  If output has been previously sent, it will raise an exception.   These are performed in order to ensure the integrity of the response emitted.  It also filters header names to normalize them; this is done in part to ensure\nthat if multiple headers of the same name are emitted, the SAPI will report them\ncorrectly.  This emitter can  always  handle a response, and thus  always  returns true.",
            "title": "SapiEmitter"
        },
        {
            "location": "/emitters/#sapistreamemitter",
            "text": "Zend\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter  behaves similarly to the SapiEmitter , with two key differences:   It allows emitting a a  content range , if a  Content-Range  header is\n  specified in the response.  It will iteratively emit a range of bytes from the response, based on the\n  buffer length provided to the emitter during construction. This is\n  particularly useful when returning  files  or  downloads .   The emitter accepts an integer argument to the constructor, indicating the\nmaximum buffer length; by default, this is 8192 bytes.  This emitter can  always  handle a response, and thus  always  returns true.",
            "title": "SapiStreamEmitter"
        },
        {
            "location": "/emitters/#emitterstack",
            "text": "Zend\\HttpHandlerRunner\\Emitter\\EmitterStack  allows providing a\nlast-in-first-out (LIFO) stack of emitters instead of a single emitter. If an\nemitter is incapable of handling the response and returns  false , the stack\nwill move to the next emitter. If an emitter returns  true , the stack\nshort-circuits and immediately returns.  The  EmitterStack  extends  SplStack , and thus allows you to add emitters using\nany of the methods that class defines; we recommend adding them in LIFO order\nusing  push() :  $stack->push($last);\n$stack->push($second);\n$stack->push($first);",
            "title": "EmitterStack"
        },
        {
            "location": "/emitters/#conditionally-using-the-sapistreamemitter",
            "text": "The  SapiStreamEmitter  is capable of emitting any response. However, for\nin-memory responses, you may want to use the more efficient  SapiEmitter . How\ncan you do this?  One way is to check for response artifacts that indicate a file download, such\nas the  Content-Disposition  or  Content-Range  headers; if those headers are\nnot present, you could return  false  from the emitter, and otherwise continue.\nYou could achieve this by decorating the  SapiStreamEmitter :  $sapiStreamEmitter = new SapiStreamEmitter($maxBufferLength);\n$conditionalEmitter = new class ($sapiStreamEmitter) implements EmitterInterface {\n    private $emitter;\n\n    public function __construct(EmitterInterface $emitter)\n    {\n        $this->emitter = $emitter;\n    }\n\n    public function emit(ResponseInterface) : bool\n    {\n        if (! $response->hasHeader('Content-Disposition')\n            && ! $response->hasHeader('Content-Range')\n        ) {\n            return false;\n        }\n        return $this->emitter->emit($response);\n    }\n};\n\n$stack = new EmitterStack();\n$stack->push(new SapiEmitter());\n$stack->push($conditionalEmitter);  In this way, you can have the best of both worlds, using the memory-efficient SapiStreamEmitter  for large file downloads or streaming buffers, and the\ngeneral-purpose  SapiEmitter  for everything else.",
            "title": "Conditionally using the SapiStreamEmitter"
        }
    ]
}